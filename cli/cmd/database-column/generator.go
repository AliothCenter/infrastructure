package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

func generateColumnFiles(modelPath string) error {
	// 获取所有 Go 文件
	files, err := os.ReadDir(modelPath)
	if err != nil {
		return err
	}

	for _, file := range files {
		if filepath.Ext(file.Name()) == ".go" {
			err := processFile(filepath.Join(modelPath, file.Name()))
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func processFile(filename string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	for _, f := range node.Decls {
		if gen, ok := f.(*ast.GenDecl); ok && gen.Tok == token.TYPE {
			for _, spec := range gen.Specs {
				if ts, ok := spec.(*ast.TypeSpec); ok {
					if structType, ok := ts.Type.(*ast.StructType); ok {
						if hasTableNameMethod(node, ts.Name.Name) {
							err := generateColumnFile(filename, ts.Name.Name, structType)
							if err != nil {
								return err
							}
						}
					}
				}
			}
		}
	}

	return nil
}

func hasTableNameMethod(node *ast.File, structName string) bool {
	for _, decl := range node.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			if funcDecl.Recv != nil && len(funcDecl.Recv.List) > 0 {
				recvType := funcDecl.Recv.List[0].Type
				// Check if the receiver is a pointer to the struct
				if starExpr, ok := recvType.(*ast.StarExpr); ok {
					if ident, ok := starExpr.X.(*ast.Ident); ok && ident.Name == structName {
						if funcDecl.Name.Name == "TableName" {
							return true
						}
					}
				}

				// Check if the receiver is the struct itself (non-pointer receiver)
				if ident, ok := recvType.(*ast.Ident); ok && ident.Name == structName {
					if funcDecl.Name.Name == "TableName" {
						return true
					}
				}
			}
		}
	}
	return false
}

func generateColumnFile(filename, structName string, structType *ast.StructType) error {
	var columns []string
	for _, field := range structType.Fields.List {
		if field.Tag != nil {
			tag := field.Tag.Value
			columnName := getColumnFromTag(tag)
			if columnName != "" {
				columns = append(columns, fmt.Sprintf("%s string", field.Names[0].Name))
			}
		}
	}

	if len(columns) == 0 {
		return nil
	}

	columnStruct := fmt.Sprintf("type %sCols struct {\n%s\n}\n", strings.ToLower(structName), strings.Join(columns, "\n"))
	columnVars := fmt.Sprintf("var %sCols = &%sCols{\n%s\n}\n", structName, strings.ToLower(structName), generateColumnVars(structType))
	generatedAnnounce := strings.Repeat("// Code generated by alioth-center/database-columns. DO NOT EDIT.\n", 3)

	output := fmt.Sprintf("%s\npackage %s\n\n%s\n%s", generatedAnnounce, getPackageName(filename), columnStruct, columnVars)

	outputFilename := strings.TrimSuffix(filename, ".go") + "_cols.gen.go"
	err := os.WriteFile(outputFilename, []byte(output), 0o644)
	if err != nil {
		return err
	}

	cmd := exec.Command("gofmt", "-w", outputFilename)
	return cmd.Run()
}

func getColumnFromTag(tag string) string {
	tag = strings.Trim(tag, "`")
	parts := strings.Split(tag, " ")
	for _, part := range parts {
		if strings.HasPrefix(part, `gorm:"`) {
			gormTags := strings.Split(strings.TrimPrefix(part, `gorm:"`), ";")
			for _, gormTag := range gormTags {
				if strings.HasPrefix(gormTag, "column:") {
					return strings.TrimPrefix(gormTag, "column:")
				}
			}
		}
	}
	return ""
}

func generateColumnVars(structType *ast.StructType) string {
	columns := []string{}
	for _, field := range structType.Fields.List {
		if field.Tag != nil {
			tag := field.Tag.Value
			columnName := getColumnFromTag(tag)
			if columnName != "" {
				columns = append(columns, fmt.Sprintf("%s: \"%s\",", field.Names[0].Name, columnName))
			}
		}
	}
	return strings.Join(columns, "\n")
}

func getPackageName(filename string) string {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.PackageClauseOnly)
	if err != nil {
		return ""
	}
	return node.Name.Name
}
